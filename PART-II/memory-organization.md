# 内存组织排布 Memory Organization

这一节主要介绍内存的组织和排布。接下来的章节中，将详细介绍两种基本的内存操作方式 - 读和写。内存可以简单划分为 只读(read-only) 和 可读写(read/write) 两种类型。并且接下来还涉及到内存的涉及问题，在章节的结尾部分，讲讲解存储多字节数据的方式，以及 数据对齐(data alignment) 为什么可以提升性能。

## 基本的内存操作

基本操作就是读写。有两种指标来衡量内存:

* 访问时间(Access time)，表示内存取回给定地址上的数据所需的时间。

* 存储周期(Memory cycle)，表示一组成功的存储操作所需的最短时间。

内存传输速率(Memory transfer rate) 有内存的 带宽(bandwidth) 决定，表示每秒传输的数据量。

读取操作时 无损(nondestructive) 型的操作，因为它不会破坏给定地址上的数据。相对的，写入操作是有损的，因为它会覆盖该地址上之前存储的数据。

接下来讲了很多的内容涉及内存的内部设计，包括如何将内存芯片进行组织起来变成更大的内存，内存自身内部如何处理内存地址的映射，内存如何存储多字节等。大致了解这些内容，有助于理解最后一小节 - 数据对齐(Alignment of Data)

## 数据对齐(Alignment of Data)

所谓数据对齐，就是 CPU 处理数据的内存地址，都必须是特定字节的整数倍。比如 C 语言中的结构体:

```c
struct MyData
{
  char d1;
  short d2;
  int d3;
};
```

其中 `d1` `d2` `d3` 的地址，都必须是特定字节的整数倍。比如有一个 32 位的处理器，要求地址必须按 4 字节对其，否则处理速度会变慢。那么经过 C 编译器的处理后，程序的任何地方使用 `myData->d1` 时，该地址都会是 4 的整数倍。这是通过 [struct padding](https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/) 来完成的。

需要注意的是，数据对其对于现代的一些 CPU 来说并不是必须的，不对齐数据不会损失任何的性能，在这个情况下再进行数据对其反而会对内存进行浪费。不过仍然存在一些现代 CPU 对于不对其的数据直接无法执行。所以为了提高程序的可移植性，一般情况下，仍然会对数据进行对其。

简单地说，之所以要讲数据进行对其，就是因为 CPU 和内存等硬件设计的特性，又或者称为缺陷。CPU 和内存等硬件在设计上，限制了不对齐数据的执行或者执行速度劣于对齐数据。

